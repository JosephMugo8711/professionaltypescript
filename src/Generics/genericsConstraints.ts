// Define the IRunnable interface with two type parameters
// T: The type of the input parameter that will be passed to the `run` method
// U: The type of the value that the `run` method will return
interface IRunnable<T, U> {
    run(parameter: T): U;  // The `run` method takes a parameter of type `T` and returns a value of type `U`
}

// Define the IRunner interface, which depends on the IRunnable interface
// T: A type that extends IRunnable, meaning T must have the `run` method
// U: The type of the input that will be passed to the `run` method of T
// V: The return type from the `run` method of T
interface IRunner<T extends IRunnable<U, V>, U, V> {
    // The `runSafe` method takes an object of type T (which has a `run` method) and a parameter of type U,
    // calls the `run` method of T with the parameter, and returns a value of type V
    runSafe(runnable: T, parameter: U): V;
}

// Example usage:

// Create a class `StringTask` that implements the IRunnable interface
// This class defines the `run` method, which takes a string and returns a number (the length of the string)
class StringTask implements IRunnable<string, number> {
    run(parameter: string): number {
        return parameter.length;  // Returns the length of the input string
    }
}

// Create an instance of IRunner using the `StringTask` class
// Here, T is `StringTask`, U is `string`, and V is `number` (input type and return type of runSafe)
const stringRunner: IRunner<StringTask, string, number> = {
    // `runSafe` takes a runnable (of type StringTask) and a parameter (of type string),
    // then calls the `run` method of the runnable and returns the result (the length of the string)
    runSafe: (runnable: StringTask, parameter: string) => runnable.run(parameter),
};

// Testing with a string input. The output will be the length of the string.
console.log(stringRunner.runSafe(new StringTask(), "Hello, world!"));  // Output: 13


// Another example: Implementing a task with no input parameter and no return value

// Create a class `SimpleTask` that implements IRunnable with `void` for both the input and return types
// This means the `run` method doesn't take any parameters and doesn't return anything
class SimpleTask implements IRunnable<void, void> {
    run(): void {
        console.log('SimpleTask is running');  // Simply logs a message to the console
    }
}

// Create an instance of IRunner using the `SimpleTask` class
// Here, both U and V are `void`, meaning `runSafe` doesn't require a parameter and doesn't return anything
const simpleRunner: IRunner<SimpleTask, void, void> = {
    // `runSafe` calls the `run` method of the SimpleTask object, which just logs a message
    runSafe: (runnable: SimpleTask) => runnable.run(),
};

// Run the simple task. This will just log the message "SimpleTask is running" to the console
simpleRunner.runSafe(new SimpleTask());  // Output: SimpleTask is running


// A more complex example: A task that takes a number as input and returns a string

// Create a class `NumberToStringTask` that implements IRunnable with a number input and a string output
class NumberToStringTask implements IRunnable<number, string> {
    run(parameter: number): string {
        return `The number is ${parameter}`;  // Returns a string describing the number
    }
}

// Create an instance of IRunner using the `NumberToStringTask` class
// Here, T is `NumberToStringTask`, U is `number`, and V is `string`
const numberRunner: IRunner<NumberToStringTask, number, string> = {
    // `runSafe` takes a runnable (of type NumberToStringTask) and a parameter (number),
    // and returns a string generated by the `run` method
    runSafe: (runnable: NumberToStringTask, parameter: number) => runnable.run(parameter),
};

// Testing with a number input. The output will be a string describing the number.
console.log(numberRunner.runSafe(new NumberToStringTask(), 42));  // Output: The number is 42
